#' Extract Predictions From An EWSmethods Object
#'
#' A function for identifying whether a warning has been generated from expanding/rolling/EWSNet early warning signal data.
#'
#' @param ews.data A dataframe of estimates generated by \code{uniEWS()}, \code{multiEWS()} or \code{ewsnet_predict()}.
#' @param sensitivity. Numeric value. For rolling or EWSNet estimates, \code{sensitivity} should equal the minimum Tau correlation or EWSNet prediction probability that constitutes a 'warning'. For rolling window EWSs, \code{sensitivity} is the number of consecutive 'signals' that constitutes a 'warning'.
#' @param outcome A two column dataframe or character matrix. The first column is a vector of system reference that matches that in \code{ews.data} (e.g. \code{"Kinneret_Monthly"}). The second column is a character vector of outcomes - either \code{"trans"} for a non-linearly transitioning system of \code{"no.trans"} for system that does not non-lnearly transition.
#' @param method String indicating the method used to generate \code{ews.data}. Options are \code{"rolling"}, \code{"expanding"} or \code{"ML"} (i.e. machine learning/EWSNet).
#' @param surrogate Boolean indicating whether a confidence interval has been generated from surrogate time series.

#' @returns A dataframe modifying \code{ews.data} with whether a threshold has been crossed `$threshold.crossed` and if that matches the expectations of \code{outcome} (\code{$prediction}).
#'


extract_ews_pred <- function(ews.data, sensitivity, outcome, method,surrogate = FALSE){
  
  require(data.table)
  require(zoo)
  require(magrittr)
  require(lubridate)
  
  if(length(dim(outcome)) != 2){
    stop("outcome should contain two columns")
  }
  outcome <- as.matrix(outcome)
  if(!inherits(outcome[,1],"character") | !inherits(outcome[,2],"character")){
    stop("Both columns of outcome should be character vectors")
  }
  if(!all(outcome[,2] %in% c("trans","no.trans"))){
    stop("Only 'trans' and 'no.trans' are accepted outcomes")
  }
  
  meth <-  match.arg(method,c("rolling","expanding","ML"))
  
  out <- data.table::as.data.table(ews.data)
  
  if(!("data_source" %in% colnames(out)) & meth != "expanding"){
    out <- cbind("data_source" = NA,out) # adds data_source if missing
  }
  
  if(!("troph_level" %in% colnames(out))){
    out <- out[,troph_level := " "] # adds trophic level if missing (is ignored later if not required)
  }
  
  if(meth == "expanding"){
    
    out <-  out %>%
      .[,time :=  zoo::as.Date(zoo::as.yearmon(time))] # convert numeric date to yearmon to date
    
    if(!("data_source" %in% colnames(out))){
      
      out <- out[,first.ews := time[rep(rle(threshold.crossed)$lengths >= sensitivity & 
                                          rle(threshold.crossed)$value == 1,
                                        times = rle(threshold.crossed)$lengths)][1], 
                 by = c("metric.code","lake","res")] %>% # find where a run of 'sensitivity' consecutive signals are flashed
        .[,interval.prior := # find difference between end of time series and where 'warning' found
            ifelse(res == "yearly",
                   lubridate::time_length(lubridate::interval(data.table::last(first.ews), data.table::last(time)), "years"),
                   lubridate::time_length(lubridate::interval(data.table::last(first.ews), data.table::last(time)), "months")), 
          by = c("metric.code","lake","res")] %>%
        data.table::setorder("lake","res","metric.code") # order results alphabetically
      
    }else{ # repeat but include data_source column
      
      out <- out[,first.ews := time[rep(rle(threshold.crossed)$lengths >= sensitivity & 
                                          rle(threshold.crossed)$value == 1,
                                        times = rle(threshold.crossed)$lengths)][1], 
                 by = c("data_source","metric.code","lake","res")] %>%
        .[,interval.prior := 
            ifelse(res == "yearly",
                   lubridate::time_length(lubridate::interval(data.table::last(first.ews), data.table::last(time)), "years"),
                   lubridate::time_length(lubridate::interval(data.table::last(first.ews), data.table::last(time)), "months")), 
          by = c("data_source","metric.code","lake","res")] %>%
        data.table::setorder("lake","res","data_source","metric.code")
    }
    
    out <- out %>% # match warning prediction to ground truth provided in 'outcome' argument
      .[,prediction := ifelse(!is.na(first.ews) & outcome[outcome[,1] %in% gsub("_ ","",paste(lake,res,troph_level,sep = "_")),2] == "no.trans","unknown", # gsub removes addtional "_ " if no trophic level given in ews.data
                              ifelse(is.na(interval.prior) & is.na(first.ews) & outcome[outcome[,1] %in% gsub("_ ","",paste(lake,res,troph_level,sep = "_")),2] == "trans", "miss",   
                                     ifelse((is.na(interval.prior) & is.na(first.ews) & outcome[outcome[,1] %in% gsub("_ ","",paste(lake,res,troph_level,sep = "_")),2] == "no.trans")|interval.prior == 0, "match", 
                                            ifelse(interval.prior > 0 & outcome[outcome[,1] %in% gsub("_ ","",paste(lake,res,troph_level,sep = "_")),2] == "trans", "prior", "post")))),
        by = c("lake","res","metric.code")] 
    
  }else if(meth == "rolling"){
    
    if(isFALSE(surrogate)){
      
      out <- out %>%   
        data.table::melt(., id.vars = c("data_source","lake","res","method","computation","troph_level"),
                         measure.vars = colnames(out)[!grepl("data_source|res|lake|method|computation|troph_level", colnames(out))],
                         variable.name = "metric.code", value.name = "metric.score") %>% # pivot EWS indicator correlations longer
        data.table::setorder("lake","res","troph_level","data_source") %>% # order alphabetically
        .[,threshold.crossed := ifelse(metric.score > sensitivity,1, 0), 
          by = c("data_source","metric.code","lake","res","troph_level")] %>% # identify warnings when correlation exceed `sensitivity`
        .[,prediction := ifelse(threshold.crossed == 0 & outcome[outcome[,1] %in% gsub("_ ","",paste(lake,res,troph_level,sep = "_")),2] == "no.trans","match",
                                ifelse(threshold.crossed == 0 & outcome[outcome[,1] %in% gsub("_ ","",paste(lake,res,troph_level,sep = "_")),2] == "trans", "miss",   
                                       ifelse(threshold.crossed == 1 & outcome[outcome[,1] %in% gsub("_ ","",paste(lake,res,troph_level,sep = "_")),2] == "no.trans", "unknown","match"))),
          by = c("lake","res","data_source","metric.code")] # match warning prediction to ground truth
    }
    if(isTRUE(surrogate)){
      
      out <- out %>%  
        .[,perm := rep(c("obs","perm")),by = c("data_source","lake","res")] %>%
        data.table::melt(.,measure.vars = colnames(out)[!grepl("data_source|res|lake|method|computation|perm|troph_level", colnames(out))],
                         variable.name = "metric.code", value.name = "metric.score") %>% # pivot EWS indicator correlations longer
        data.table::dcast(., data_source + lake + res + metric.code + method + computation + troph_level~ perm, value.var = "metric.score") %>% # and pivot back wider in to observed and permuted values
        .[,threshold.crossed := ifelse(obs > 0 & perm >= sensitivity,1, 0), 
          by = c("data_source","perm","metric.code","lake","res","troph_level")] %>%
        .[,prediction := ifelse(threshold.crossed == 0 & outcome[outcome[,1] %in% gsub("_ ","",paste(lake,res,troph_level,sep = "_")),2] == "no.trans","match",
                                ifelse(threshold.crossed == 0 & outcome[outcome[,1] %in% gsub("_ ","",paste(lake,res,troph_level,sep = "_")),2] == "trans", "miss",   
                                       ifelse(threshold.crossed == 1 & outcome[outcome[,1] %in% gsub("_ ","",paste(lake,res,troph_level,sep = "_")),2] == "no.trans", "unknown","match"))),
          by = c("lake","res","data_source","metric.code")]
      
    }
    
  }else if(meth == "ML"){
    
    out <- out %>%  
      .[, model_ensemble := NULL] %>%
      data.table::melt(., id.vars = c("data_source","lake","res","method","computation","troph_level"),
                       measure.vars = c("no_transScaled","smth_transScaled","crt_transScaled","no_transUnscaled","smth_transUnscaled","crt_transUnscaled"), 
                       #value.name = c("scaled_prob", "unscaled_prob"),
                       value.name = c("prob"),
                       variable.name = "pos_outcome") %>% # pivot probabilities longer
      .[, c("pos_outcome", "scaling") := data.table::tstrsplit(pos_outcome, "_", fixed = TRUE)] %>% # split probabilities in to scaled vs unscaled
      .[, pos_outcome := ifelse(pos_outcome == "no", "none",
                                ifelse(pos_outcome == "smth","smooth","critical"))] %>% # and tidy up naming conventions
      .[, scaling := ifelse(grepl("Scaled",scaling), "scaled","unscaled")] %>% 
      .[, ewsnet_prediction := pos_outcome[which.max(prob)], by = c("data_source","lake","res","scaling")] %>% # identify strongest prediction outcome 
      data.table::setorder("lake","res","data_source") %>% # order alphabetically
      .[, threshold.crossed := ifelse(prob > sensitivity, 1, 0), 
        by = c("data_source","lake","res","scaling")] # identify warnings when correlation exceed `sensitivity` 
    
    tmp <- data.table::copy(out)[pos_outcome == ewsnet_prediction,] %>% # on subset of data (the strongest prediction for each time series)
      .[,prediction := ifelse(threshold.crossed == 0  & outcome[outcome[,1] %in% gsub("_ ","",paste(lake,res,troph_level,sep = "_")),2] == "no.trans", "match",
                              ifelse(threshold.crossed == 0 & ewsnet_prediction == "critical" & outcome[outcome[,1] %in% gsub("_ ","",paste(lake,res,troph_level,sep = "_")),2] == "trans", "miss",   
                                     ifelse(threshold.crossed == 1 & ewsnet_prediction == "critical" & outcome[outcome[,1] %in% gsub("_ ","",paste(lake,res,troph_level,sep = "_")),2] == "no.trans", "unknown",
                                            ifelse(threshold.crossed == 1 & ewsnet_prediction == "critical" & outcome[outcome[,1] %in% gsub("_ ","",paste(lake,res,troph_level,sep = "_")),2] == "trans", "match",
                                                   ifelse(threshold.crossed == 1 & ewsnet_prediction == "smooth" & outcome[outcome[,1] %in% gsub("_ ","",paste(lake,res,troph_level,sep = "_")),2] == "no.trans","match",
                                                          "miss"))))),
        by = c("lake","res","scaling","data_source")] # match warning prediction to ground truth
    
    out <- out[tmp, on =  c("data_source","lake","res","scaling","troph_level"), prediction := i.prediction] # merge tmp subset to main data.table and fill missing values
    
  }
  
  
  return(as.data.frame(out))
  
}
